<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>AquaBot</title>
  <!--Import font(s)-->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">

  <!--Add Favicon-->
  <link rel="icon" type="image/png" href="favicon.png">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <style>
    :root {
      --bg: #0b0f17;
      --panel: #141b28;
      --muted: #1e293b;
      --text: #f5f7fb;
      --primary: #4da6ff;
      --accent: #093f6d;
      --danger: #ff5a5a;
      --warn: #f39c12;
    }

    * {
      box-sizing: border-box
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: "Roboto", system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Helvetica, Arial, sans-serif
    }

    @media (min-width: 510px) {
      header {
        display: flex;
        justify-content: space-between;
      }
    }

    header {
      padding: 18px 12px;
      text-align: center;
      background: #101623;
      box-shadow: 0 2px 12px rgba(0, 0, 0, .35)
    }

    header h1 {
      margin: 0;
      font-size: 22px;
      color: var(--primary)
    }

    header p {
      margin: 6px 0 0;
      opacity: .8
    }

    .container {
      max-width: 1080px;
      margin: 20px auto;
      padding: 0 12px
    }

    .tabs {
      display: flex;
      gap: 8px;
      flex-wrap: wrap
    }

    .tab-btn {
      flex: 1;
      min-width: 180px;
      padding: 12px 14px;
      border: none;
      border-radius: 10px;
      background: var(--muted);
      color: #fff;
      font-weight: 700;
      cursor: pointer;
      transition: .25s
    }

    .tab-btn:hover {
      transform: translateY(-1px)
    }

    .tab-btn.active {
      background: var(--primary);
      color: #0a0a0a
    }

    .card {
      margin-top: 12px;
      background: var(--panel);
      border-radius: 14px;
      box-shadow: 0 6px 24px rgba(0, 0, 0, .35);
      overflow: hidden;
      animation: fadeIn .45s ease
    }

    .card-header {
      padding: 12px 14px;
      background: linear-gradient(90deg, var(--accent), var(--primary));
      font-weight: 800;
      margin: 10px;
      border-radius: 8px;
    }

    .card-body {
      padding: 14px
    }

    .tab {
      display: none
    }

    .tab.active {
      display: block;
      animation: rise .35s ease
    }

    @keyframes fadeIn {
      from {
        opacity: 0
      }

      to {
        opacity: 1
      }
    }

    @keyframes rise {
      from {
        opacity: 0;
        transform: translateY(10px)
      }

      to {
        opacity: 1;
        transform: translateY(0)
      }
    }

    /* Map w/ AC4 tint */
    #map {
      height: 440px;
      width: 100%;
      border-radius: 12px;
      background: #0e1a1a
    }

    .leaflet-tile.ac4 {
      filter: hue-rotate(140deg) saturate(1.3) brightness(.95) contrast(1.08)
    }

    .leaflet-marker-icon,
    .leaflet-popup {
      transition: transform .25s ease
    }

    /* Info grid */
    .info-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 10px
    }

    .info-box {
      background: var(--muted);
      border-radius: 12px;
      padding: 12px;
      transition: transform .25s ease
    }

    .info-box:hover {
      transform: translateY(-3px)
    }

    .info-title {
      opacity: .85;
      margin-bottom: 6px
    }

    .info-big {
      font-size: 1.2rem;
      font-weight: 800
    }

    /* Chart block */
    .chart-wrap {
      margin-top: 14px;
      background: #0f1826;
      border: 1px solid #213047;
      border-radius: 12px;
      padding: 12px
    }

    .chart-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 10px
    }

    .small-btn {
      padding: .5rem .8rem;
      border: none;
      border-radius: 10px;
      background: var(--accent);
      color: #fff;
      font-weight: 700;
      cursor: pointer;
      transition: .2s
    }

    .small-btn.alt {
      background: var(--primary)
    }

    .small-btn:hover {
      transform: translateY(-1px)
    }

    /* Chat */
    .chat-wrap {
      display: flex;
      flex-direction: column;
      height: 470px
    }

    .chat-messages {
      flex: 1;
      overflow-y: auto;
      background: #101826;
      border: 1px solid #213047;
      border-radius: 12px;
      padding: 12px
    }

    .msg {
      max-width: 80%;
      margin: 8px 0;
      padding: 10px 14px;
      border-radius: 16px;
      word-wrap: break-word;
      line-height: 1.45;
      opacity: 0;
      animation: pop .3s ease forwards
    }

    @keyframes pop {
      from {
        opacity: 0;
        transform: translateY(8px)
      }

      to {
        opacity: 1;
        transform: translateY(0)
      }
    }

    .user {
      align-self: flex-end;
      background: var(--primary);
      color: #fff;
      border-bottom-right-radius: 6px
    }

    .bot {
      align-self: flex-start;
      background: #2d3b52;
      color: #eff3ff;
      border-bottom-left-radius: 6px
    }

    .typing {
      opacity: .75;
      font-style: italic
    }

    .chat-input {
      display: flex;
      gap: 8px;
      margin-top: 10px
    }

    .chat-input input {
      flex: 1;
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid #2b3c55;
      background: #0f1826;
      color: #fff;
      transition: border .2s
    }

    .chat-input input:focus {
      border-color: #3d82ff
    }

    .chat-input button {
      padding: 0 16px;
      border: none;
      border-radius: 999px;
      background: var(--danger);
      color: #fff;
      font-weight: 900;
      cursor: pointer;
      transition: .2s
    }

    .chat-input button:hover {
      transform: translateY(-1px)
    }

    .risk-row {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px
    }

    .risk-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%
    }

    .low {
      background: #27ae60
    }

    .med {
      background: #f39c12
    }

    .high {
      background: #e74c3c
    }

    .actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 10px;
      justify-content: center;
    }

    .btn {
      padding: .55rem .9rem;
      border: none;
      border-radius: 10px;
      background: var(--accent);
      color: #fff;
      font-weight: 700;
      cursor: pointer;
      transition: .2s;
      
    }

    .btn:hover {
      transform: translateY(-1px)
    }

    .btn.alt {
      background: var(--primary)
    }

    .btn.warn {
      background: var(--warn);
      color: #121212
    }

    footer {
      text-align: center;
      opacity: .6;
      padding: 16px 0
    }
  </style>
</head>

<body>
  <header>
    <h1>AquaBot</h1>
    <p>Live Map ‚Ä¢ Tide & Weather ‚Ä¢ AI Assistant</p>
  </header>

  <div class="container">
    <div class="tabs">
      <button class="tab-btn active" data-tab="map-tab">üåç Map</button>
      <button class="tab-btn" data-tab="info-tab">üå¶Ô∏è Tide & Weather</button>
      <button class="tab-btn" data-tab="chat-tab">ü§ñ AquaBot</button>
    </div>

    <section id="map-tab" class="tab active">
      <div class="card">
        <div class="card-header">Flood Risk & Location</div>
        <div class="card-body">
          <div class="risk-row">
            <div id="riskDot" class="risk-dot low"></div>
            <div id="riskText">Detecting your location‚Ä¶</div>
          </div>
          <div id="map"></div>
          <div class="actions">
            <button id="btnLocate" class="btn alt">Refresh Location & Risk</button>
            <button id="btnClear" class="btn warn">Clear Overlays</button>
          </div>
        </div>
      </div>
    </section>

    <section id="info-tab" class="tab">
      <div class="card">
        <div class="card-header">Tide & Weather</div>
        <div class="card-body">
          <div class="info-grid">
            <div class="info-box">
              <div class="info-title">Temperature</div>
              <div id="tempBox" class="info-big">-- ¬∞C</div>
            </div>
            <div class="info-box">
              <div class="info-title">Rain (chance)</div>
              <div id="rainBox" class="info-big">-- %</div>
            </div>
            <div class="info-box">
              <div class="info-title">Humidity</div>
              <div id="humBox" class="info-big">-- %</div>
            </div>
            <div class="info-box">
              <div class="info-title">Tide</div>
              <div id="tideBox" class="info-big">--</div>
            </div>
            <div class="info-box">
              <div class="info-title">Next High / Low</div>
              <div id="tideNext">--</div>
            </div>
          </div>

          <div class="chart-wrap">
            <div class="chart-actions">
              <button id="btnTide" class="small-btn alt">Tide (24h)</button>
              <button id="btnTemp" class="small-btn">Temperature (24h)</button>
            </div>
            <canvas id="infoChart" height="140"></canvas>
          </div>

          <div class="actions">
            <button id="btnRefreshInfo" class="btn">Refresh Tide & Weather</button>
          </div>
        </div>
      </div>
    </section>

    <section id="chat-tab" class="tab">
      <div class="card">
        <div class="card-header">AquaBot Assistant</div>
        <div class="card-body">
          <div class="chat-wrap">
            <div id="chat" class="chat-messages"></div>
            <div class="chat-input">
              <input id="chatInput" type="text"
                placeholder="Ask about flooding, raining now, tide timing, safety tips‚Ä¶" />
              <button id="chatSend">Send</button>
            </div>
          </div>
        </div>
      </div>
    </section>
  </div>

  <footer>¬© 2025 AquaBot</footer>

  <script>
    /* Tabs */
    const tabBtns = [
      ...document.querySelectorAll('.tab-btn')
    ];
    tabBtns.forEach(b => b.onclick = () => {
      tabBtns.forEach(x => x.classList.remove('active'));
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      b.classList.add('active');
      document.getElementById(b.dataset.tab).classList.add('active');
      if (b.dataset.tab === 'map-tab') {
        setTimeout(() => map.invalidateSize(), 120);
      }
    });

    /* Map (AC4 style) */
    let map = L.map('map', {
      zoomControl: true
    }).setView([20, 0], 2);
    const carto = L.Browser.retina
      ? 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}@2x.png'
      : 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png';
    L.tileLayer(carto, {
      attribution: '¬© OpenStreetMap ‚Ä¢ CARTO',
      subdomains: 'abcd',
      maxZoom: 19,
      className: 'ac4'
    }).addTo(map);
    let userMarker = null,
      riskCircle = null;

    // Estimate flood risk based on rain chance and humidity
    function estimateFloodRisk(rainChance, humidity) {
      if (rainChance === null || rainChance === undefined || isNaN(rainChance)) {
        return {
          label: 'Unknown',
          cls: 'low',
          color: '#27ae60',
          radius: 500
        };
      }
      if (rainChance >= 70 || humidity >= 85) {
        return {
          label: 'High',
          cls: 'high',
          color: '#e74c3c',
          radius: 1500
        };
      }
      if (rainChance >= 40 || humidity >= 70) {
        return {
          label: 'Medium',
          cls: 'med',
          color: '#f39c12',
          radius: 1000
        };
      }
      return {
        label: 'Low',
        cls: 'low',
        color: '#27ae60',
        radius: 500
      };
    }
    function updateRiskUI(r, city) {
      document.getElementById('riskDot').className = 'risk-dot ' + r.cls;
      let txt = '';
      if (r.label === 'High')
        txt = 'üö® High Flood Risk ‚Äî avoid low-lying roads.';
      else if (r.label === 'Medium')
        txt = '‚ö†Ô∏è Moderate Flood Risk ‚Äî stay alert.';
      else if (r.label === 'Low')
        txt = '‚úÖ Low Flood Risk';
      else
        txt = 'Flood risk unknown.';
      if (city) txt += ` (${city})`;
      document.getElementById('riskText').textContent = txt;
    }
    async function getCityName(lat, lon) {
      try {
        const url = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${lat}&lon=${lon}`;
        const r = await fetch(url);
        const d = await r.json();
        return d.address?.city || d.address?.town || d.address?.village || d.address?.state || '';
      } catch (e) { return ''; }
    }

    async function drawAt(lat, lon) {
      if (userMarker) map.removeLayer(userMarker);
      if (riskCircle) map.removeLayer(riskCircle);
      userMarker = L.marker([lat, lon])
        .addTo(map)
        .bindPopup('Your location')
        .openPopup();
      // Use weather data for risk
      let rainChance = ctxCache.rainChance;
      let humidity = ctxCache.humidity;
      const r = estimateFloodRisk(rainChance, humidity);
      riskCircle = L.circle([lat, lon], {
        radius: r.radius,
        color: r.color,
        fillColor: r.color,
        fillOpacity: .28
      }).addTo(map);
      const city = await getCityName(lat, lon);
      updateRiskUI(r, city);
      map.setView([lat, lon], 13);
    }
    async function ipFallback() {
      try {
        // Use ip-api.com for free IP geolocation
        const r = await fetch('https://ip-api.io/json');
        const d = await r.json();
        if (d && d.latitude && d.longitude) {
          return { lat: d.latitude, lon: d.longitude };
        }
      } catch (e) {}
      // fallback to New York
      return { lat: 40.7128, lon: -74.0060 };
    }

    async function locate() {
      const t = document.getElementById('riskText');
      t.textContent = 'Detecting your location‚Ä¶';
      let pos;
      if (!navigator.geolocation) {
        t.textContent = 'Geolocation not supported. Using IP.';
        console.log('Geolocation not supported, falling back to IP-based location.');
        pos = await ipFallback();
      } else {
        try {
          pos = await new Promise((resolve, reject) => {
            navigator.geolocation.getCurrentPosition(
              p => resolve({ lat: p.coords.latitude, lon: p.coords.longitude }),
              async _ => {
                t.textContent = 'Location blocked ‚Äî using IP.';
                const ipPos = await ipFallback();
                resolve(ipPos);
              },
              {
                enableHighAccuracy: true,
                timeout: 8000,
                maximumAge: 0
              }
            );
          });
        } catch (e) {
          pos = await ipFallback();
        }
      }
      // Fetch weather before drawing risk
      await fetchWeather(pos.lat, pos.lon);
      await drawAt(pos.lat, pos.lon);
    }
    document.getElementById('btnLocate').onclick = locate;
    document.getElementById('btnClear').onclick = () => {
      if (userMarker) {
        map.removeLayer(userMarker);
        userMarker = null;
      }
      if (riskCircle) {
        map.removeLayer(riskCircle);
        riskCircle = null;
      }
      document.getElementById('riskText').textContent = 'Overlays cleared.';
      document.getElementById('riskDot').className = 'risk-dot low';
    };
    locate();
    window.addEventListener('resize', () => map.invalidateSize());

    /* ===== Data sources / cache ===== */
    const WT_KEY = 'GET_THE_HELL_OUT_OF_HERE'; // WorldTides key
    let ctxCache = { lat: null, lon: null, city: '', temp: null, humidity: null, rainChance: null, tideState: null, nextHigh: null, nextLow: null, tideSeries: [], tempSeries: [], timeSeries: [] };

    async function getCoords() {
      // Try browser geolocation, then IP, then NY
      return new Promise(res => {
        if (!navigator.geolocation) {
          ipFallback().then(res);
          return;
        }
        navigator.geolocation.getCurrentPosition(
          p => res({ lat: p.coords.latitude, lon: p.coords.longitude }),
          async _ => {
            const pos = await ipFallback();
            res(pos);
          }
        );
      });
    }

    /* Weather: Open-Meteo (no key) */
    async function fetchWeather(lat, lon) {
      try {
        const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true&hourly=temperature_2m,relative_humidity_2m,precipitation_probability&timezone=auto`;
        const r = await fetch(url); const d = await r.json();
        const cw = d.current_weather || {};
        ctxCache.temp = Math.round(cw.temperature ?? d.hourly?.temperature_2m?.[0] ?? NaN);
        ctxCache.humidity = d.hourly?.relative_humidity_2m?.[0] ?? NaN;
        ctxCache.rainChance = d.hourly?.precipitation_probability?.[0] ?? (cw.weathercode ? (cw.weathercode >= 50 ? 60 : 20) : '--');

        document.getElementById('tempBox').textContent = isNaN(ctxCache.temp) ? '-- ¬∞C' : `${ctxCache.temp} ¬∞C`;
        document.getElementById('humBox').textContent = isNaN(ctxCache.humidity) ? '-- %' : `${ctxCache.humidity} %`;
        document.getElementById('rainBox').textContent = (ctxCache.rainChance === undefined || ctxCache.rainChance === null) ? '-- %' : `${ctxCache.rainChance} %`;

        const hours = d.hourly?.time?.slice(0, 24) ?? [];
        ctxCache.timeSeries = hours.map(t => new Date(t));
        ctxCache.tempSeries = (d.hourly?.temperature_2m ?? []).slice(0, 24);
      } catch (e) {
        document.getElementById('tempBox').textContent = '-- ¬∞C';
        document.getElementById('humBox').textContent = '-- %';
        document.getElementById('rainBox').textContent = '-- %';
      }
    }

/* Tides: WorldTides (24h from now) */
async function fetchTides(lat, lon) {
  try {
    // Open-Meteo Marine API for wave height
    const url = `https://marine-api.open-meteo.com/v1/marine?latitude=${lat}&longitude=${lon}&hourly=wave_height&timezone=auto`;
    const r = await fetch(url);
    const d = await r.json();
    const times = d.hourly?.time || [];
    const heights = d.hourly?.wave_height || [];

    if (!times.length || !heights.length) {
      document.getElementById('tideBox').textContent = 'No wave data';
      document.getElementById('tideNext').textContent = '--';
      ctxCache.tideSeries = [];
      return;
    }

    // Use wave height as 'tide' for demo purposes
    ctxCache.tideSeries = times.map((t, i) => ({ t: new Date(t), y: heights[i] }));
    ctxCache.timeSeries = times.map(t => new Date(t));

    // Find current and next max/min wave height
    const nowMs = Date.now();
    let currIdx = times.findIndex(t => new Date(t).getTime() > nowMs);
    if (currIdx === -1) currIdx = 0;
    ctxCache.tideState = heights[currIdx] !== undefined ? `${heights[currIdx].toFixed(2)} m` : '--';

    // Find next high/low wave
    let nextHigh = null, nextLow = null;
    for (let i = currIdx + 1; i < heights.length; i++) {
      if (heights[i] > heights[currIdx]) nextHigh = times[i];
      if (heights[i] < heights[currIdx]) nextLow = times[i];
      if (nextHigh && nextLow) break;
    }
    const fmt = t => t ? new Date(t).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : '--';
    document.getElementById('tideBox').textContent = `Wave: ${ctxCache.tideState}`;
    document.getElementById('tideNext').textContent = `Next Higher: ${fmt(nextHigh)} ‚Ä¢ Next Lower: ${fmt(nextLow)}`;
  } catch (e) {
    document.getElementById('tideBox').textContent = 'No wave data';
    document.getElementById('tideNext').textContent = '--';
    ctxCache.tideSeries = [];
  }
}


    /* Refresh info */
    async function refreshInfo() {
      const pos = await getCoords();
      ctxCache.lat = pos.lat; ctxCache.lon = pos.lon;
      await Promise.all([fetchWeather(pos.lat, pos.lon), fetchTides(pos.lat, pos.lon)]);
      updateChart(); // redraw
    }
    document.getElementById('btnRefreshInfo').onclick = refreshInfo;

    /* Chart.js setup */
    const ctx = document.getElementById('infoChart').getContext('2d');
    let currentMode = 'tide';
    const chart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: [], datasets: [
          { label: 'Tide Height (m)', data: [], borderWidth: 2, tension: .35, fill: true },
          { label: 'Temperature (¬∞C)', data: [], borderWidth: 2, tension: .35, fill: false, hidden: true }
        ]
      },
      options: {
        responsive: true,
        animation: { duration: 700, easing: 'easeOutCubic' },
        interaction: { mode: 'index', intersect: false },
        scales: {
          x: {
            ticks: {
              callback: (value, index) => {
                const d = chart.data.labels[index];
                if (!d) return '';
                try { return new Date(d).toLocaleTimeString([], { hour: '2-digit' }); }
                catch (e) { return String(d); }
              }
            }
          },
          y: { beginAtZero: false }
        },
        plugins: { legend: { labels: { boxWidth: 14 } } }
      }
    });
    function updateChart() {
      const labels = ctxCache.timeSeries.length ? ctxCache.timeSeries.map(d => d) : [];
      chart.data.labels = labels;
      const tideY = ctxCache.tideSeries.length ? ctxCache.tideSeries.map(p => p.y) : [];
      const tempY = ctxCache.tempSeries.length ? ctxCache.tempSeries : [];
      chart.data.datasets[0].data = tideY;
      chart.data.datasets[1].data = tempY;
      chart.data.datasets[0].hidden = (currentMode !== 'tide');
      chart.data.datasets[1].hidden = (currentMode !== 'temp');
      chart.update();
    }
    document.getElementById('btnTide').onclick = () => {
      currentMode = 'tide';
      document.getElementById('btnTide').classList.add('alt');
      document.getElementById('btnTemp').classList.remove('alt');
      updateChart();
    }
    document.getElementById('btnTemp').onclick = () => {
      currentMode = 'temp';
      document.getElementById('btnTemp').classList.add('alt');
      document.getElementById('btnTide').classList.remove('alt');
      updateChart();
    }

    /* Initial load */
    refreshInfo();

    /* ===== Chatbot (fuzzy intent) ===== */
    const chat = document.getElementById('chat');
    function addMsg(text, who = 'bot') {
      const d = document.createElement('div');
      d.className = 'msg ' + (who === 'user' ? 'user' : 'bot');
      d.textContent = text;
      chat.appendChild(d);
      chat.scrollTop = chat.scrollHeight;
    }
    function addTyping() {
      const d = document.createElement('div');
      d.className = 'msg bot typing';
      d.textContent = 'AquaBot is typing‚Ä¶';
      chat.appendChild(d);
      chat.scrollTop = chat.scrollHeight;
      return d;
    }
    addMsg("Hey! I‚Äôm AquaBot. Ask about rain, flood risk, or tides.");

    function norm(s) {
      return s
        .toLowerCase()
        .replace(/[^a-z0-9\s]/g, ' ')
        .replace(/\s+/g, ' ')
        .trim();
    }
    function sim(a, b) {
      const m = [];
      for (let i = 0; i <= a.length; i++) {
        m[i] = [i];
      }
      for (let j = 0; j <= b.length; j++) {
        m[0][j] = j;
      }
      for (let i = 1; i <= a.length; i++) {
        for (let j = 1; j <= b.length; j++) {
          m[i][j] = Math.min(
            m[i - 1][j] + 1,
            m[i][j - 1] + 1,
            m[i - 1][j - 1] + (a[i - 1] == b[j - 1] ? 0 : 1)
          );
        }
      }
      const dist = m[a.length][b.length];
      return 1 - (dist / Math.max(a.length, b.length || 1));
    }
    function fuzzyContains(text, kws, th = .78) {
      const words = text.split(' ');
      for (const w of [...words, text])
        for (const k of kws) {
          if (
            w.includes(k) ||
            text.includes(k) ||
            sim(w, k) >= th
          ) return true;
        }
      return false;
    }
    const intentSyn = { greet: ["hello", "hi", "hey", "yo", "sup", "hola"], rain: ["rain", "raining", "rainy", "downpour", "drizzle", "storm", "stormy"], flood: ["flood", "flooding", "waterlogging", "inundation", "overflow"], tide: ["tide", "tides", "high tide", "low tide", "surge", "sea"], temp: ["temp", "temperature", "hot", "cold", "chill"], hum: ["humidity", "humid", "sticky"], thanks: ["thanks", "thank you", "thx", "ty"], help: ["help", "sos", "urgent", "assist", "support"] };
    function detectIntent(t) { if (fuzzyContains(t, intentSyn.thanks)) return "thanks"; if (fuzzyContains(t, intentSyn.help)) return "help"; if (fuzzyContains(t, intentSyn.greet)) return "greet"; if (fuzzyContains(t, intentSyn.flood)) return "flood"; if (fuzzyContains(t, intentSyn.rain)) return "rain"; if (fuzzyContains(t, intentSyn.tide)) return "tide"; if (fuzzyContains(t, intentSyn.temp)) return "temp"; if (fuzzyContains(t, intentSyn.hum)) return "hum"; return "unknown"; }
    function smartReply(msg) {
      const t = norm(msg);
      const intent = detectIntent(t);
      const fmt = (d) =>
        d
          ? new Date(d).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
          : '--';

      if (intent === "greet")
        return "Hello! Ask me: ‚Äúis it raining now?‚Äù, ‚Äúnext high tide?‚Äù, or ‚Äúflood tips‚Äù.";

      if (intent === "thanks")
        return "Anytime! Stay safe out there.";

      if (intent === "help")
        return "I can check rain, tides, basic flood risk tips. If it‚Äôs urgent, contact local authorities.";

      if (intent === "rain") {
        if (ctxCache.temp != null && ctxCache.rainChance != null)
          return `Around ${ctxCache.temp}¬∞C. Rain chance ‚âà ${ctxCache.rainChance}%. See Tide & Weather for details.`;
        return "Weather is loading ‚Äî open Tide & Weather or tap Refresh.";
      }

      if (intent === "temp") {
        return ctxCache.temp != null
          ? `Current temperature ~ ${ctxCache.temp}¬∞C. Switch the chart to Temperature for the next 24h.`
          : "Temperature loading ‚Äî try again in a moment.";
      }

      if (intent === "hum") {
        return ctxCache.humidity != null
          ? `Humidity around ${ctxCache.humidity}%. Keep rooms ventilated to reduce damp.`
          : "Humidity loading ‚Äî hit Refresh in Tide & Weather.";
      }

      if (intent === "flood") {
        const base = "Avoid underpasses/low streets. Don‚Äôt drive through water.";
        if (ctxCache.rainChance != null && ctxCache.rainChance >= 60)
          return `Rain chance ~${ctxCache.rainChance}% so pooling is possible. ${base}`;
        return base + " Keep drains clear and watch alerts.";
      }

      if (intent === "tide") {
        if (ctxCache.tideState)
          return `Current tide: ${ctxCache.tideState}. Next High: ${fmt(ctxCache.nextHigh)} ‚Ä¢ Next Low: ${fmt(ctxCache.nextLow)}. Toggle chart to Tide for 24h curve.`;
        return "Tide data loading ‚Äî press Refresh in Tide & Weather.";
      }

      return "I can help with rain, temperature, humidity, flooding, and tides. Try: ‚Äúraining rn?‚Äù, ‚Äúnext low tide‚Äù, or ‚Äúflood tips‚Äù.";
    }

    const chatInput = document.getElementById('chatInput');
    document.getElementById('chatSend').onclick = () => {
      const v = chatInput.value.trim();
      if (!v) return;
      addMsg(v, 'user');
      chatInput.value = '';
      const typing = addTyping();
      setTimeout(() => {
        typing.remove();
        addMsg(smartReply(v), 'bot');
      }, 320);
    };
    chatInput.addEventListener('keypress', e => {
      if (e.key === 'Enter')
        document.getElementById('chatSend').click();
    });
  </script>
</body>

</html>